# AI协作上下文工程指南 (Context Engineering Guide)

## 概述
> "Context Engineering is the art of providing all the context for the task to be plausibly solvable by the LLM." - Simon Willison

本指南基于Simon Willison的Context Engineering理念，提供与AI协作开发时的上下文管理最佳实践。

---

## 🎯 核心理念

### Context Engineering vs Prompt Engineering

#### ❌ 传统的Prompt Engineering思维
```
用户: "帮我写一个登录功能"
AI: [产出可能不符合项目需求的通用代码]
```

#### ✅ Context Engineering思维
```
用户: 
项目背景: iOS应用，SwiftUI + MVVM架构
技术约束: iOS 15+，本地存储优先
安全要求: Face ID/Touch ID支持，加密存储
现有代码: [提供相关的数据模型和服务]
具体需求: 实现生物识别登录，失败时降级到密码
成功标准: 响应时间<2秒，通过安全审查

请帮我实现符合上述要求的登录功能。
```

### 上下文的组成要素

#### 1. **项目上下文 (Project Context)**
- 项目类型和规模
- 技术栈和架构模式
- 开发阶段和迭代计划
- 团队组成和技能水平

#### 2. **技术上下文 (Technical Context)**
- 现有代码结构和模式
- 依赖关系和版本信息
- 性能和安全要求
- 兼容性约束

#### 3. **业务上下文 (Business Context)**
- 用户需求和使用场景
- 业务逻辑和流程要求
- 优先级和时间限制
- 质量和合规标准

#### 4. **任务上下文 (Task Context)**
- 具体要解决的问题
- 预期的输入输出格式
- 成功标准和验收条件
- 潜在的风险和边界情况

---

## 📋 Context Engineering实践模板

### 🚀 功能开发请求模板

```markdown
## 任务: [具体功能名称]

### 📍 项目上下文
- **项目**: [项目名称和类型]
- **阶段**: [开发阶段，如Week 2 of MVP]
- **架构**: [技术架构，如SwiftUI + MVVM + Core ML]
- **风格**: [设计风格，如小红书风格]

### 🔧 技术上下文
- **平台**: [iOS 15+/Android API 28+/Web等]
- **语言**: [Swift/Kotlin/JavaScript等]
- **框架**: [具体的框架和版本]
- **依赖**: [关键依赖库和版本]

### 📊 性能要求
- **响应时间**: [具体时间要求]
- **内存使用**: [内存限制]
- **电池消耗**: [电量影响要求]
- **网络使用**: [网络依赖程度]

### 🏗️ 现有代码结构
[提供相关的代码片段和结构]

```swift
// 相关的数据模型
struct User {
    let id: UUID
    let name: String
    // ...
}

// 现有的服务接口
protocol AuthenticationService {
    func login(credentials: Credentials) async throws -> User
}

// 当前的实现模式
extension ViewModel {
    func handleUserAction() {
        // 现有的处理模式
    }
}
```

### 🎯 具体需求
- **功能描述**: [详细的功能要求]
- **输入输出**: [明确的接口规范]
- **错误处理**: [异常情况的处理要求]
- **用户体验**: [UI/UX的具体要求]

### ✅ 成功标准
- **功能性**: [功能完整性要求]
- **性能**: [可衡量的性能指标]
- **质量**: [代码质量和测试要求]
- **用户体验**: [用户满意度指标]

### 🚨 约束条件
- **技术约束**: [不能使用的技术或方法]
- **时间约束**: [开发时间限制]
- **资源约束**: [人力和资金限制]
- **合规要求**: [法律法规和隐私要求]
```

### 🐛 问题解决请求模板

```markdown
## 问题: [简短的问题描述]

### 📍 环境信息
- **项目**: [项目名称和版本]
- **平台**: [操作系统和版本]
- **开发环境**: [IDE和工具版本]
- **设备**: [测试设备信息]

### 🔄 问题重现步骤 (三次尝试记录)
#### 第1次尝试
- **方法**: [尝试的解决方法]
- **结果**: [实际发生的情况]
- **学习**: [从这次尝试学到的信息]

#### 第2次尝试  
- **方法**: [不同的解决方法]
- **结果**: [实际发生的情况]
- **学习**: [从这次尝试学到的信息]

#### 第3次尝试
- **方法**: [第三种解决方法]
- **结果**: [实际发生的情况]
- **学习**: [从这次尝试学到的信息]

### 📋 完整错误信息
[粘贴完整的错误日志和堆栈跟踪]

### 🧩 相关代码
[提供出问题的代码段和相关上下文]

```swift
// 出问题的代码
func problematicFunction() {
    // 问题代码
}

// 调用该函数的上下文
class ViewController {
    func handleAction() {
        problematicFunction() // 这里发生错误
    }
}
```

### 🎯 期望结果
[描述期望的正确行为]

### 🔍 已检查的内容
- [ ] 官方文档和API说明
- [ ] Stack Overflow相关问题
- [ ] GitHub Issues搜索
- [ ] 代码逻辑检查
- [ ] 依赖版本兼容性
```

---

## 🛠️ 上下文优化技巧

### 1. **分层上下文策略**

#### Level 1: 全局上下文 (项目级别)
```markdown
保存在项目文档中，每次交互都引用:
- 项目技术栈和架构
- 开发规范和编码标准  
- 关键的业务规则
- 性能和质量要求
```

#### Level 2: 模块上下文 (功能级别)
```markdown
针对特定功能模块的上下文:
- 模块的职责和边界
- 相关的数据模型
- 现有的服务接口
- 模块间的依赖关系
```

#### Level 3: 任务上下文 (具体任务)
```markdown
针对当前具体任务的上下文:
- 要解决的具体问题
- 相关的代码片段
- 具体的技术约束
- 明确的成功标准
```

### 2. **渐进式上下文构建**

#### 第一轮：建立基础上下文
```markdown
先提供基本的项目信息和技术栈，
让AI理解项目的整体情况。
```

#### 第二轮：补充具体上下文
```markdown
基于AI的回应，补充更具体的
需求细节和技术约束。
```

#### 第三轮：精确化和验证
```markdown
确认AI理解正确，提供最终的
实现要求和验收标准。
```

### 3. **上下文复用策略**

#### 创建上下文模板库
```
/project-context/
├── project-overview.md      # 项目总体情况
├── tech-stack.md           # 技术栈详情
├── coding-standards.md     # 编码规范
├── architecture-patterns.md # 架构模式
└── common-interfaces.md    # 常用接口
```

#### 快速上下文引用
```markdown
基础上下文: 参考 @project-overview.md 和 @tech-stack.md
架构模式: 遵循 @architecture-patterns.md 中的MVVM模式
编码规范: 按照 @coding-standards.md 的要求
```

---

## 📊 上下文质量评估

### 检查清单

#### ✅ 完整性检查
```markdown
□ 项目背景信息是否完整?
□ 技术约束是否明确?
□ 现有代码上下文是否相关?
□ 成功标准是否可衡量?
□ 潜在风险是否被识别?
```

#### ✅ 准确性检查  
```markdown
□ 提供的代码示例是否最新?
□ 技术版本信息是否正确?
□ 业务逻辑描述是否准确?
□ 依赖关系是否正确?
```

#### ✅ 相关性检查
```markdown
□ 提供的信息是否与任务相关?
□ 上下文详细程度是否合适?
□ 是否包含了多余的信息?
□ 重点信息是否突出?
```

### 常见上下文问题及解决方案

#### 问题1: 上下文过载
```markdown
症状: AI回应混乱，抓不住重点
解决: 分层提供上下文，先提供核心信息
```

#### 问题2: 上下文不足
```markdown
症状: AI产出与预期差距很大
解决: 补充相关的代码示例和业务逻辑
```

#### 问题3: 上下文过期
```markdown
症状: AI基于老版本的信息给出建议
解决: 建立上下文更新机制，及时同步变更
```

---

## 🎨 不同场景的上下文策略

### 场景1: 新功能开发

#### 上下文重点
```markdown
- 详细的业务需求和用户故事
- 现有系统的相关接口和模式
- 技术选型的约束和偏好
- 性能和质量的具体要求
```

#### 示例上下文
```markdown
需求: 为电商应用添加商品推荐功能
现有架构: 微服务架构，商品服务已存在
数据源: 用户行为数据、商品特征数据
约束: 响应时间<200ms，推荐精度>80%
```

### 场景2: Bug修复

#### 上下文重点
```markdown
- 完整的错误重现步骤
- 相关的代码和配置信息
- 错误发生的环境和条件
- 已尝试的解决方案历史
```

#### 示例上下文
```markdown
错误: 用户登录后偶发性地看不到订单历史
环境: iOS 15.5，iPhone 12，应用版本2.1.3
重现: 登录后立即点击订单Tab，约30%概率复现
已尝试: 检查网络请求、验证数据库查询、重启应用
```

### 场景3: 代码重构

#### 上下文重点
```markdown
- 现有代码的问题和限制
- 重构的目标和预期收益
- 必须保持的向后兼容性
- 重构的范围和边界
```

#### 示例上下文
```markdown
目标: 重构用户服务，提高可测试性
问题: 当前代码耦合度高，难以单元测试
约束: 不能改变公开API，必须保持数据兼容
范围: UserService及其依赖的3个helper类
```

### 场景4: 性能优化

#### 上下文重点
```markdown
- 具体的性能问题和测量数据
- 现有架构和可能的瓶颈点
- 优化目标和可接受的权衡
- 资源限制和技术约束
```

#### 示例上下文
```markdown
问题: 商品列表页面加载慢，平均响应时间3.2秒
目标: 减少到800ms以内
瓶颈: 数据库查询复杂，图片加载未优化
约束: 不能改变数据模型，内存使用不能增加50%以上
```

---

## 🔄 持续改进上下文工程

### 反馈循环建立

#### 1. 收集效果数据
```markdown
每次AI协作后记录:
- 一次性成功率
- 需要澄清的轮数
- 最终结果质量评分
- AI理解准确度评估
```

#### 2. 分析问题模式
```markdown
定期分析:
- 哪类上下文经常缺失?
- 哪些信息容易被AI误解?
- 什么样的表达方式最有效?
- 哪些模板需要优化?
```

#### 3. 优化上下文策略
```markdown
基于分析结果:
- 更新上下文模板
- 调整信息提供顺序
- 改进关键概念的表达
- 增加常见场景的示例
```

### 团队协作中的上下文管理

#### 建立共同的上下文词汇
```markdown
团队内统一使用的概念:
- 技术术语和缩写
- 业务领域概念
- 架构模式名称
- 常用工具和流程名称
```

#### 上下文知识库维护
```markdown
团队共享的知识库:
- 项目技术文档
- 常见问题解答
- 最佳实践案例
- 上下文模板库
```

---

## 🎓 Context Engineering进阶技巧

### 1. 认知负载管理
```markdown
避免一次性提供过多信息:
- 先提供核心上下文，再补充细节
- 使用结构化格式组织信息
- 突出最重要的约束和要求
- 分阶段深入具体实现细节
```

### 2. 上下文压缩技术
```markdown
在token限制内最大化信息密度:
- 使用表格和列表结构化信息
- 去掉冗余和重复内容
- 使用缩写和标准术语
- 重点信息前置和标记
```

### 3. 多轮对话中的上下文管理
```markdown
保持对话连贯性:
- 引用之前的交互结果
- 明确当前阶段和目标
- 及时纠正AI的误解
- 总结关键决策和变更
```

### 4. 跨项目的上下文复用
```markdown
建立可复用的上下文资产:
- 技术栈标准描述模板
- 常见架构模式说明
- 通用业务概念定义
- 质量标准和规范文档
```

---

*指南版本: 1.0*  
*基于: Simon Willison Context Engineering理念*  
*最后更新: 2025-08-29*  
*维护者: 开发团队*